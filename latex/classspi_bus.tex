\hypertarget{classspi_bus}{}\section{spi\+Bus Class Reference}
\label{classspi_bus}\index{spi\+Bus@{spi\+Bus}}


Basic S\+PI functions like write and read a register.  




{\ttfamily \#include $<$spi\+Bus.\+hpp$>$}

Inheritance diagram for spi\+Bus\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classspi_bus}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classspi_bus_a042e32891d6fffd4b4eb706600244062}{spi\+Bus}} (hwlib\+::pin\+\_\+out \&scl, hwlib\+::pin\+\_\+out \&mosi, hwlib\+::pin\+\_\+in \&miso)
\begin{DoxyCompactList}\small\item\em This is a constructor for the Spi\+Bus class. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{classspi_bus_ab6b195b235dd0a1dad2f7cec3d997ffb}{get\+Byte\+From\+Register}} (const uint8\+\_\+t chip\+Reg\+Address, hwlib\+::pin\+\_\+out \&slave\+Select)
\begin{DoxyCompactList}\small\item\em Get only one byte from a specific register. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classspi_bus_a58318fdc7b4ff1869be4f0f321a853a8}{get\+Bytes\+From\+Register}} (const uint8\+\_\+t chip\+Reg\+Address, uint8\+\_\+t data\mbox{[}$\,$\mbox{]}, const uint8\+\_\+t amount\+Of\+Bytes, hwlib\+::pin\+\_\+out \&slave\+Select)
\begin{DoxyCompactList}\small\item\em Get multiple byte from a specific register. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classspi_bus_a3322a039f33a7180a9a57da662607b7d}{set\+Byte\+In\+Register}} (const uint8\+\_\+t chip\+Reg\+Address, uint8\+\_\+t byte, hwlib\+::pin\+\_\+out \&slave\+Select)
\begin{DoxyCompactList}\small\item\em Set a byte into a specific register. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classspi_bus_a734591a2184ce01cac6dcf875ac424d4}{set\+Bytes\+In\+Register}} (const uint8\+\_\+t chip\+Reg\+Address, uint8\+\_\+t new\+Bytes\mbox{[}$\,$\mbox{]}, const uint8\+\_\+t amount\+Of\+Bytes, hwlib\+::pin\+\_\+out \&slave\+Select)
\begin{DoxyCompactList}\small\item\em Set multiple bytes starting from a specific register. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
uint8\+\_\+t \mbox{\hyperlink{classspi_bus_a6e5f0193b056b4b58db49e1c6ce5d807}{get\+Read\+Byte}} (const uint8\+\_\+t chip\+Reg\+Address)
\begin{DoxyCompactList}\small\item\em this function will create a read byte using a specific register. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{classspi_bus_af09ae8625cbb1c5353e3777af6bf5ae3}{get\+Write\+Byte}} (const uint8\+\_\+t chip\+Reg\+Address)
\begin{DoxyCompactList}\small\item\em this function will create a write byte using a specific register. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
const uint8\+\_\+t \mbox{\hyperlink{classspi_bus_a0dda31f7fa031ef8913e029d2eb4acf9}{R\+E\+A\+D\+\_\+\+M\+A\+SK}} = 0x80
\begin{DoxyCompactList}\small\item\em This mask should be used before sending the register byte W\+H\+EN R\+E\+A\+D\+I\+NG. \end{DoxyCompactList}\item 
const uint8\+\_\+t \mbox{\hyperlink{classspi_bus_acd898d08216428963563e20f033423b3}{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK}} = 0x7E
\begin{DoxyCompactList}\small\item\em This mask should be used before sending the register byte when reading or writing. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Basic S\+PI functions like write and read a register. 

This class is a wrapper around the hwlib\+::spi\+\_\+bus\+\_\+bit\+\_\+banged\+\_\+sclk\+\_\+mosi\+\_\+miso (\href{mailto:wouter@voti.nl}{\tt wouter@voti.\+nl} 2017). It contains some basic S\+PI functions for easy access of the used chip. \begin{DoxyWarning}{Warning}
T\+HE S\+O\+F\+T\+W\+A\+RE IS P\+R\+O\+V\+I\+D\+ED \char`\"{}\+A\+S I\+S\char`\"{}, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+TY OF A\+NY K\+I\+ND. 
\end{DoxyWarning}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classspi_bus_a042e32891d6fffd4b4eb706600244062}\label{classspi_bus_a042e32891d6fffd4b4eb706600244062}} 
\index{spi\+Bus@{spi\+Bus}!spi\+Bus@{spi\+Bus}}
\index{spi\+Bus@{spi\+Bus}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{spi\+Bus()}{spiBus()}}
{\footnotesize\ttfamily spi\+Bus\+::spi\+Bus (\begin{DoxyParamCaption}\item[{hwlib\+::pin\+\_\+out \&}]{scl,  }\item[{hwlib\+::pin\+\_\+out \&}]{mosi,  }\item[{hwlib\+::pin\+\_\+in \&}]{miso }\end{DoxyParamCaption})}



This is a constructor for the Spi\+Bus class. 


\begin{DoxyParams}{Parameters}
{\em scl} & the Serial Clock Line. \\
\hline
{\em mosi} & the Master Output Slave Input. data from master -\/$>$ slave. \\
\hline
{\em miso} & the Master Input Slave Output. data from slave -\/$>$ master. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classspi_bus_ab6b195b235dd0a1dad2f7cec3d997ffb}\label{classspi_bus_ab6b195b235dd0a1dad2f7cec3d997ffb}} 
\index{spi\+Bus@{spi\+Bus}!get\+Byte\+From\+Register@{get\+Byte\+From\+Register}}
\index{get\+Byte\+From\+Register@{get\+Byte\+From\+Register}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{get\+Byte\+From\+Register()}{getByteFromRegister()}}
{\footnotesize\ttfamily uint8\+\_\+t spi\+Bus\+::get\+Byte\+From\+Register (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t}]{chip\+Reg\+Address,  }\item[{hwlib\+::pin\+\_\+out \&}]{slave\+Select }\end{DoxyParamCaption})}



Get only one byte from a specific register. 


\begin{DoxyParams}{Parameters}
{\em chip\+Reg\+Address} & the register you want to get the byte of. \\
\hline
{\em slave\+Select} & the pin the slave select of the slave you want to read from. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A uint8\+\_\+t which contains the byte of the given register.
\end{DoxyReturn}
This method sends one bytes to the slave over the mosi. The first byte is the read register byte created by \mbox{\hyperlink{classspi_bus_a6e5f0193b056b4b58db49e1c6ce5d807}{get\+Read\+Byte}}. After sending the byte the miso will receive the byte of the chip\+Reg\+Address. The data is send and received by hwlib\+::spi\+\_\+bus\+\_\+bit\+\_\+banged\+\_\+sclk\+\_\+mosi\+\_\+miso.\+write\+\_\+and\+\_\+read() (\href{mailto:wouter@voti.nl}{\tt wouter@voti.\+nl} 2017) \mbox{\Hypertarget{classspi_bus_a58318fdc7b4ff1869be4f0f321a853a8}\label{classspi_bus_a58318fdc7b4ff1869be4f0f321a853a8}} 
\index{spi\+Bus@{spi\+Bus}!get\+Bytes\+From\+Register@{get\+Bytes\+From\+Register}}
\index{get\+Bytes\+From\+Register@{get\+Bytes\+From\+Register}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{get\+Bytes\+From\+Register()}{getBytesFromRegister()}}
{\footnotesize\ttfamily void spi\+Bus\+::get\+Bytes\+From\+Register (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t}]{chip\+Reg\+Address,  }\item[{uint8\+\_\+t}]{data\mbox{[}$\,$\mbox{]},  }\item[{const uint8\+\_\+t}]{amount\+Of\+Bytes,  }\item[{hwlib\+::pin\+\_\+out \&}]{slave\+Select }\end{DoxyParamCaption})}



Get multiple byte from a specific register. 


\begin{DoxyParams}{Parameters}
{\em chip\+Reg\+Address} & the register you want the bytes from. \\
\hline
{\em data\mbox{[}$\,$\mbox{]}} & a pointer to an array where the bytes will be stored in. \\
\hline
{\em amount\+Of\+Bytes} & the amount of bytes you want to get. \\
\hline
{\em slave\+Select} & the pin the slave select of the slave you want to read from.\\
\hline
\end{DoxyParams}
First this function creates a new array to store the retreived data in. This array will be one step bigger than the amount\+Of\+Bytes you want to retreive. After creating the array a read byte using the chip\+Reg\+Address and \mbox{\hyperlink{classspi_bus_a6e5f0193b056b4b58db49e1c6ce5d807}{get\+Read\+Byte}} The array will be filled with this read byte. After using hwlib\+::spi\+\_\+bus\+\_\+bit\+\_\+banged\+\_\+sclk\+\_\+mosi\+\_\+miso.\+write\+\_\+and\+\_\+read() (\href{mailto:wouter@voti.nl}{\tt wouter@voti.\+nl} 2017) It will fill your given array with the retreived data. \begin{DoxyWarning}{Warning}
The size of the array must at least be the amount\+Of\+Bytes! 

The given chip\+Reg\+Address will read multiple times. Some registers will be empty after reading. R\+E\+AD T\+HE D\+A\+T\+A\+S\+H\+E\+ET B\+E\+F\+O\+RE U\+S\+I\+N\+G! 
\end{DoxyWarning}
\mbox{\Hypertarget{classspi_bus_a6e5f0193b056b4b58db49e1c6ce5d807}\label{classspi_bus_a6e5f0193b056b4b58db49e1c6ce5d807}} 
\index{spi\+Bus@{spi\+Bus}!get\+Read\+Byte@{get\+Read\+Byte}}
\index{get\+Read\+Byte@{get\+Read\+Byte}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{get\+Read\+Byte()}{getReadByte()}}
{\footnotesize\ttfamily uint8\+\_\+t spi\+Bus\+::get\+Read\+Byte (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t}]{chip\+Reg\+Address }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



this function will create a read byte using a specific register. 


\begin{DoxyParams}{Parameters}
{\em chip\+Reg\+Address} & the register address you want to get the read chip register byte of. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A uint8\+\_\+t which contains the read register byte.
\end{DoxyReturn}
The read register byte is the chip\+Reg\+Address shifted one bit to the left and the \mbox{\hyperlink{classspi_bus_acd898d08216428963563e20f033423b3}{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK}} and \mbox{\hyperlink{classspi_bus_a0dda31f7fa031ef8913e029d2eb4acf9}{R\+E\+A\+D\+\_\+\+M\+A\+SK}} operated on it. \mbox{\Hypertarget{classspi_bus_af09ae8625cbb1c5353e3777af6bf5ae3}\label{classspi_bus_af09ae8625cbb1c5353e3777af6bf5ae3}} 
\index{spi\+Bus@{spi\+Bus}!get\+Write\+Byte@{get\+Write\+Byte}}
\index{get\+Write\+Byte@{get\+Write\+Byte}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{get\+Write\+Byte()}{getWriteByte()}}
{\footnotesize\ttfamily uint8\+\_\+t spi\+Bus\+::get\+Write\+Byte (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t}]{chip\+Reg\+Address }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [private]}}



this function will create a write byte using a specific register. 


\begin{DoxyParams}{Parameters}
{\em chip\+Reg\+Address} & the register address you want to get the write chip register byte of. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A uint8\+\_\+t which contains the write register byte.
\end{DoxyReturn}
The write register byte is the chip\+Reg\+Address shifted one bit to the left and the \mbox{\hyperlink{classspi_bus_acd898d08216428963563e20f033423b3}{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK}} operated on it. \mbox{\Hypertarget{classspi_bus_a3322a039f33a7180a9a57da662607b7d}\label{classspi_bus_a3322a039f33a7180a9a57da662607b7d}} 
\index{spi\+Bus@{spi\+Bus}!set\+Byte\+In\+Register@{set\+Byte\+In\+Register}}
\index{set\+Byte\+In\+Register@{set\+Byte\+In\+Register}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{set\+Byte\+In\+Register()}{setByteInRegister()}}
{\footnotesize\ttfamily void spi\+Bus\+::set\+Byte\+In\+Register (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t}]{chip\+Reg\+Address,  }\item[{uint8\+\_\+t}]{byte,  }\item[{hwlib\+::pin\+\_\+out \&}]{slave\+Select }\end{DoxyParamCaption})}



Set a byte into a specific register. 


\begin{DoxyParams}{Parameters}
{\em chip\+Reg\+Address} & the register you want the byte of. \\
\hline
{\em byte} & the byte you want to set into the chip\+Reg\+Address. \\
\hline
{\em slave\+Select} & the pin the slave select of the slave you want to write to.\\
\hline
\end{DoxyParams}
A array will be created and a write register byte will be set to the first index. The write register byte will be generated using \mbox{\hyperlink{classspi_bus_af09ae8625cbb1c5353e3777af6bf5ae3}{get\+Write\+Byte}}. The second index of the array will be the byte you want to sent. The bytes will be send using hwlib\+::spi\+\_\+bus\+\_\+bit\+\_\+banged\+\_\+sclk\+\_\+mosi\+\_\+miso.\+write\+\_\+and\+\_\+read() (\href{mailto:wouter@voti.nl}{\tt wouter@voti.\+nl} 2017) \begin{DoxyWarning}{Warning}
The value in the register will be overridden. 
\end{DoxyWarning}
\mbox{\Hypertarget{classspi_bus_a734591a2184ce01cac6dcf875ac424d4}\label{classspi_bus_a734591a2184ce01cac6dcf875ac424d4}} 
\index{spi\+Bus@{spi\+Bus}!set\+Bytes\+In\+Register@{set\+Bytes\+In\+Register}}
\index{set\+Bytes\+In\+Register@{set\+Bytes\+In\+Register}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{set\+Bytes\+In\+Register()}{setBytesInRegister()}}
{\footnotesize\ttfamily void spi\+Bus\+::set\+Bytes\+In\+Register (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t}]{chip\+Reg\+Address,  }\item[{uint8\+\_\+t}]{new\+Bytes\mbox{[}$\,$\mbox{]},  }\item[{const uint8\+\_\+t}]{amount\+Of\+Bytes,  }\item[{hwlib\+::pin\+\_\+out \&}]{slave\+Select }\end{DoxyParamCaption})}



Set multiple bytes starting from a specific register. 


\begin{DoxyParams}{Parameters}
{\em chip\+Reg\+Address} & the register you want start getting the bytes from. \\
\hline
{\em data\mbox{[}$\,$\mbox{]}} & a pointer to an array where the bytes you want to send are stored. \\
\hline
{\em amount\+Of\+Bytes} & the amount of bytes you want to set. \\
\hline
{\em slave\+Select} & the pin the slave select of the slave you want to write to.\\
\hline
\end{DoxyParams}
First a new array will be created one size bigger than amount\+Of\+Bytes. The first byte will be the register write byte generated by \mbox{\hyperlink{classspi_bus_af09ae8625cbb1c5353e3777af6bf5ae3}{get\+Write\+Byte}}. The rest of the array will be filled with the data in the new\+Bytes array. After setting up the array it will be send to the chip using hwlib\+::spi\+\_\+bus\+\_\+bit\+\_\+banged\+\_\+sclk\+\_\+mosi\+\_\+miso.\+write\+\_\+and\+\_\+read() (\href{mailto:wouter@voti.nl}{\tt wouter@voti.\+nl} 2017). \begin{DoxyWarning}{Warning}
The size of new\+Bytes\mbox{[}\mbox{]} should be amount\+Of\+Bytes. 
\end{DoxyWarning}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{classspi_bus_a0dda31f7fa031ef8913e029d2eb4acf9}\label{classspi_bus_a0dda31f7fa031ef8913e029d2eb4acf9}} 
\index{spi\+Bus@{spi\+Bus}!R\+E\+A\+D\+\_\+\+M\+A\+SK@{R\+E\+A\+D\+\_\+\+M\+A\+SK}}
\index{R\+E\+A\+D\+\_\+\+M\+A\+SK@{R\+E\+A\+D\+\_\+\+M\+A\+SK}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{R\+E\+A\+D\+\_\+\+M\+A\+SK}{READ\_MASK}}
{\footnotesize\ttfamily const uint8\+\_\+t spi\+Bus\+::\+R\+E\+A\+D\+\_\+\+M\+A\+SK = 0x80\hspace{0.3cm}{\ttfamily [private]}}



This mask should be used before sending the register byte W\+H\+EN R\+E\+A\+D\+I\+NG. 

This mask will always set the M\+SB to H\+I\+G\+H/1. The M\+SB has to be high to read from a S\+PI chip. Setting the same bit to a L\+O\+W/0 means it will be writing to a S\+PI chip. \begin{DoxyWarning}{Warning}
Always use the \mbox{\hyperlink{classspi_bus_acd898d08216428963563e20f033423b3}{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK}} before sending the register byte(first byte). 
\end{DoxyWarning}
\mbox{\Hypertarget{classspi_bus_acd898d08216428963563e20f033423b3}\label{classspi_bus_acd898d08216428963563e20f033423b3}} 
\index{spi\+Bus@{spi\+Bus}!R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK@{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK}}
\index{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK@{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK}!spi\+Bus@{spi\+Bus}}
\subsubsection{\texorpdfstring{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK}{REGISTER\_MASK}}
{\footnotesize\ttfamily const uint8\+\_\+t spi\+Bus\+::\+R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+M\+A\+SK = 0x7E\hspace{0.3cm}{\ttfamily [private]}}



This mask should be used before sending the register byte when reading or writing. 

This mask will always set the M\+SB to L\+O\+W/0 and will always set the L\+SB to L\+O\+W/0. The M\+SB has to be L\+OW to read from a S\+PI chip and the L\+SB must always be low because it\textquotesingle{}s not used by the chip All the other bits represent the register address you want to communicate with. You must always use this mask before sending the register byte(first byte). 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Demo/spi\+Bus.\+hpp\item 
Demo/spi\+Bus.\+cpp\end{DoxyCompactItemize}
