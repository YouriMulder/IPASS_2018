<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IPASS Youri Mulder (Alarm system): spiBus Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IPASS Youri Mulder (Alarm system)
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classspi_bus-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">spiBus Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic SPI functions like write and read a register.  
 <a href="classspi_bus.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="spi_bus_8hpp_source.html">spiBus.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for spiBus:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classspi_bus.png" usemap="#spiBus_map" alt=""/>
  <map id="spiBus_map" name="spiBus_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a042e32891d6fffd4b4eb706600244062"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#a042e32891d6fffd4b4eb706600244062">spiBus</a> (hwlib::pin_out &amp;scl, hwlib::pin_out &amp;mosi, hwlib::pin_in &amp;miso)</td></tr>
<tr class="memdesc:a042e32891d6fffd4b4eb706600244062"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a constructor for the SpiBus class.  <a href="#a042e32891d6fffd4b4eb706600244062">More...</a><br /></td></tr>
<tr class="separator:a042e32891d6fffd4b4eb706600244062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b195b235dd0a1dad2f7cec3d997ffb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#ab6b195b235dd0a1dad2f7cec3d997ffb">getByteFromRegister</a> (const uint8_t chipRegAddress, hwlib::pin_out &amp;slaveSelect)</td></tr>
<tr class="memdesc:ab6b195b235dd0a1dad2f7cec3d997ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only one byte from a specific register.  <a href="#ab6b195b235dd0a1dad2f7cec3d997ffb">More...</a><br /></td></tr>
<tr class="separator:ab6b195b235dd0a1dad2f7cec3d997ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58318fdc7b4ff1869be4f0f321a853a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#a58318fdc7b4ff1869be4f0f321a853a8">getBytesFromRegister</a> (const uint8_t chipRegAddress, uint8_t data[], const uint8_t amountOfBytes, hwlib::pin_out &amp;slaveSelect)</td></tr>
<tr class="memdesc:a58318fdc7b4ff1869be4f0f321a853a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get multiple byte from a specific register.  <a href="#a58318fdc7b4ff1869be4f0f321a853a8">More...</a><br /></td></tr>
<tr class="separator:a58318fdc7b4ff1869be4f0f321a853a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3322a039f33a7180a9a57da662607b7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#a3322a039f33a7180a9a57da662607b7d">setByteInRegister</a> (const uint8_t chipRegAddress, uint8_t byte, hwlib::pin_out &amp;slaveSelect)</td></tr>
<tr class="memdesc:a3322a039f33a7180a9a57da662607b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a byte into a specific register.  <a href="#a3322a039f33a7180a9a57da662607b7d">More...</a><br /></td></tr>
<tr class="separator:a3322a039f33a7180a9a57da662607b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734591a2184ce01cac6dcf875ac424d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#a734591a2184ce01cac6dcf875ac424d4">setBytesInRegister</a> (const uint8_t chipRegAddress, uint8_t newBytes[], const uint8_t amountOfBytes, hwlib::pin_out &amp;slaveSelect)</td></tr>
<tr class="memdesc:a734591a2184ce01cac6dcf875ac424d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple bytes starting from a specific register.  <a href="#a734591a2184ce01cac6dcf875ac424d4">More...</a><br /></td></tr>
<tr class="separator:a734591a2184ce01cac6dcf875ac424d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6e5f0193b056b4b58db49e1c6ce5d807"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#a6e5f0193b056b4b58db49e1c6ce5d807">getReadByte</a> (const uint8_t chipRegAddress)</td></tr>
<tr class="memdesc:a6e5f0193b056b4b58db49e1c6ce5d807"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function will create a read byte using a specific register.  <a href="#a6e5f0193b056b4b58db49e1c6ce5d807">More...</a><br /></td></tr>
<tr class="separator:a6e5f0193b056b4b58db49e1c6ce5d807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09ae8625cbb1c5353e3777af6bf5ae3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#af09ae8625cbb1c5353e3777af6bf5ae3">getWriteByte</a> (const uint8_t chipRegAddress)</td></tr>
<tr class="memdesc:af09ae8625cbb1c5353e3777af6bf5ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">this function will create a write byte using a specific register.  <a href="#af09ae8625cbb1c5353e3777af6bf5ae3">More...</a><br /></td></tr>
<tr class="separator:af09ae8625cbb1c5353e3777af6bf5ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0dda31f7fa031ef8913e029d2eb4acf9"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#a0dda31f7fa031ef8913e029d2eb4acf9">READ_MASK</a> = 0x80</td></tr>
<tr class="memdesc:a0dda31f7fa031ef8913e029d2eb4acf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mask should be used before sending the register byte WHEN READING.  <a href="#a0dda31f7fa031ef8913e029d2eb4acf9">More...</a><br /></td></tr>
<tr class="separator:a0dda31f7fa031ef8913e029d2eb4acf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd898d08216428963563e20f033423b3"><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classspi_bus.html#acd898d08216428963563e20f033423b3">REGISTER_MASK</a> = 0x7E</td></tr>
<tr class="memdesc:acd898d08216428963563e20f033423b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mask should be used before sending the register byte when reading or writing.  <a href="#acd898d08216428963563e20f033423b3">More...</a><br /></td></tr>
<tr class="separator:acd898d08216428963563e20f033423b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic SPI functions like write and read a register. </p>
<p>This class is a wrapper around the hwlib::spi_bus_bit_banged_sclk_mosi_miso (<a href="#" onclick="location.href='mai'+'lto:'+'wou'+'te'+'r@v'+'ot'+'i.n'+'l'; return false;">woute<span style="display: none;">.nosp@m.</span>r@vo<span style="display: none;">.nosp@m.</span>ti.nl</a> 2017). It contains some basic SPI functions for easy access of the used chip. </p><dl class="section warning"><dt>Warning</dt><dd>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a042e32891d6fffd4b4eb706600244062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042e32891d6fffd4b4eb706600244062">&#9670;&nbsp;</a></span>spiBus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">spiBus::spiBus </td>
          <td>(</td>
          <td class="paramtype">hwlib::pin_out &amp;&#160;</td>
          <td class="paramname"><em>scl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_out &amp;&#160;</td>
          <td class="paramname"><em>mosi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_in &amp;&#160;</td>
          <td class="paramname"><em>miso</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a constructor for the SpiBus class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scl</td><td>the Serial Clock Line. </td></tr>
    <tr><td class="paramname">mosi</td><td>the Master Output Slave Input, data from master -&gt; slave. </td></tr>
    <tr><td class="paramname">miso</td><td>the Master Input Slave Output, data from slave -&gt; master. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab6b195b235dd0a1dad2f7cec3d997ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b195b235dd0a1dad2f7cec3d997ffb">&#9670;&nbsp;</a></span>getByteFromRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spiBus::getByteFromRegister </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>chipRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_out &amp;&#160;</td>
          <td class="paramname"><em>slaveSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get only one byte from a specific register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipRegAddress</td><td>the register you want to get the byte of. </td></tr>
    <tr><td class="paramname">slaveSelect</td><td>the pin the slave select of the slave you want to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint8_t which contains the byte of the given register.</dd></dl>
<p>This method sends one bytes to the slave over the mosi. The first byte is the read register byte created by <a class="el" href="classspi_bus.html#a6e5f0193b056b4b58db49e1c6ce5d807" title="this function will create a read byte using a specific register. ">getReadByte</a>. After sending the byte the miso will receive the byte of the chipRegAddress. The data is send and received by hwlib::spi_bus_bit_banged_sclk_mosi_miso.write_and_read() (<a href="#" onclick="location.href='mai'+'lto:'+'wou'+'te'+'r@v'+'ot'+'i.n'+'l'; return false;">woute<span style="display: none;">.nosp@m.</span>r@vo<span style="display: none;">.nosp@m.</span>ti.nl</a> 2017) </p>

</div>
</div>
<a id="a58318fdc7b4ff1869be4f0f321a853a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58318fdc7b4ff1869be4f0f321a853a8">&#9670;&nbsp;</a></span>getBytesFromRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spiBus::getBytesFromRegister </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>chipRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>amountOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_out &amp;&#160;</td>
          <td class="paramname"><em>slaveSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get multiple byte from a specific register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipRegAddress</td><td>the register you want the bytes from. </td></tr>
    <tr><td class="paramname">data[]</td><td>a pointer to an array where the bytes will be stored in. </td></tr>
    <tr><td class="paramname">amountOfBytes</td><td>the amount of bytes you want to get. </td></tr>
    <tr><td class="paramname">slaveSelect</td><td>the pin the slave select of the slave you want to read from.</td></tr>
  </table>
  </dd>
</dl>
<p>First this function creates a new array to store the retreived data in. This array will be one step bigger than the amountOfBytes you want to retreive. After creating the array a read byte using the chipRegAddress and <a class="el" href="classspi_bus.html#a6e5f0193b056b4b58db49e1c6ce5d807" title="this function will create a read byte using a specific register. ">getReadByte</a> The array will be filled with this read byte. After using hwlib::spi_bus_bit_banged_sclk_mosi_miso.write_and_read() (<a href="#" onclick="location.href='mai'+'lto:'+'wou'+'te'+'r@v'+'ot'+'i.n'+'l'; return false;">woute<span style="display: none;">.nosp@m.</span>r@vo<span style="display: none;">.nosp@m.</span>ti.nl</a> 2017) It will fill your given array with the retreived data. </p><dl class="section warning"><dt>Warning</dt><dd>The size of the array must at least be the amountOfBytes! </dd>
<dd>
The given chipRegAddress will read multiple times. Some registers will be empty after reading. READ THE DATASHEET BEFORE USING! </dd></dl>

</div>
</div>
<a id="a6e5f0193b056b4b58db49e1c6ce5d807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5f0193b056b4b58db49e1c6ce5d807">&#9670;&nbsp;</a></span>getReadByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spiBus::getReadByte </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>chipRegAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function will create a read byte using a specific register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipRegAddress</td><td>the register address you want to get the read chip register byte of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint8_t which contains the read register byte.</dd></dl>
<p>The read register byte is the chipRegAddress shifted one bit to the left and the <a class="el" href="classspi_bus.html#acd898d08216428963563e20f033423b3" title="This mask should be used before sending the register byte when reading or writing. ">REGISTER_MASK</a> and <a class="el" href="classspi_bus.html#a0dda31f7fa031ef8913e029d2eb4acf9" title="This mask should be used before sending the register byte WHEN READING. ">READ_MASK</a> operated on it. </p>

</div>
</div>
<a id="af09ae8625cbb1c5353e3777af6bf5ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09ae8625cbb1c5353e3777af6bf5ae3">&#9670;&nbsp;</a></span>getWriteByte()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t spiBus::getWriteByte </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>chipRegAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this function will create a write byte using a specific register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipRegAddress</td><td>the register address you want to get the write chip register byte of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A uint8_t which contains the write register byte.</dd></dl>
<p>The write register byte is the chipRegAddress shifted one bit to the left and the <a class="el" href="classspi_bus.html#acd898d08216428963563e20f033423b3" title="This mask should be used before sending the register byte when reading or writing. ">REGISTER_MASK</a> operated on it. </p>

</div>
</div>
<a id="a3322a039f33a7180a9a57da662607b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3322a039f33a7180a9a57da662607b7d">&#9670;&nbsp;</a></span>setByteInRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spiBus::setByteInRegister </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>chipRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_out &amp;&#160;</td>
          <td class="paramname"><em>slaveSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a byte into a specific register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipRegAddress</td><td>the register you want the byte of. </td></tr>
    <tr><td class="paramname">byte</td><td>the byte you want to set into the chipRegAddress. </td></tr>
    <tr><td class="paramname">slaveSelect</td><td>the pin the slave select of the slave you want to write to.</td></tr>
  </table>
  </dd>
</dl>
<p>A array will be created and a write register byte will be set to the first index. The write register byte will be generated using <a class="el" href="classspi_bus.html#af09ae8625cbb1c5353e3777af6bf5ae3" title="this function will create a write byte using a specific register. ">getWriteByte</a>. The second index of the array will be the byte you want to sent. The bytes will be send using hwlib::spi_bus_bit_banged_sclk_mosi_miso.write_and_read() (<a href="#" onclick="location.href='mai'+'lto:'+'wou'+'te'+'r@v'+'ot'+'i.n'+'l'; return false;">woute<span style="display: none;">.nosp@m.</span>r@vo<span style="display: none;">.nosp@m.</span>ti.nl</a> 2017) </p><dl class="section warning"><dt>Warning</dt><dd>The value in the register will be overridden. </dd></dl>

</div>
</div>
<a id="a734591a2184ce01cac6dcf875ac424d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734591a2184ce01cac6dcf875ac424d4">&#9670;&nbsp;</a></span>setBytesInRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spiBus::setBytesInRegister </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>chipRegAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>newBytes</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>amountOfBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">hwlib::pin_out &amp;&#160;</td>
          <td class="paramname"><em>slaveSelect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multiple bytes starting from a specific register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chipRegAddress</td><td>the register you want start getting the bytes from. </td></tr>
    <tr><td class="paramname">newBytes[]</td><td>a pointer to an array where the bytes you want to send are stored. </td></tr>
    <tr><td class="paramname">amountOfBytes</td><td>the amount of bytes you want to set. </td></tr>
    <tr><td class="paramname">slaveSelect</td><td>the pin the slave select of the slave you want to write to.</td></tr>
  </table>
  </dd>
</dl>
<p>First a new array will be created one size bigger than amountOfBytes. The first byte will be the register write byte generated by <a class="el" href="classspi_bus.html#af09ae8625cbb1c5353e3777af6bf5ae3" title="this function will create a write byte using a specific register. ">getWriteByte</a>. The rest of the array will be filled with the data in the newBytes array. After setting up the array it will be send to the chip using hwlib::spi_bus_bit_banged_sclk_mosi_miso.write_and_read() (<a href="#" onclick="location.href='mai'+'lto:'+'wou'+'te'+'r@v'+'ot'+'i.n'+'l'; return false;">woute<span style="display: none;">.nosp@m.</span>r@vo<span style="display: none;">.nosp@m.</span>ti.nl</a> 2017). </p><dl class="section warning"><dt>Warning</dt><dd>The size of newBytes[] should be amountOfBytes. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0dda31f7fa031ef8913e029d2eb4acf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dda31f7fa031ef8913e029d2eb4acf9">&#9670;&nbsp;</a></span>READ_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t spiBus::READ_MASK = 0x80</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This mask should be used before sending the register byte WHEN READING. </p>
<p>This mask will always set the MSB to HIGH/1. The MSB has to be high to read from a SPI chip. Setting the same bit to a LOW/0 means it will be writing to a SPI chip. </p><dl class="section warning"><dt>Warning</dt><dd>Always use the <a class="el" href="classspi_bus.html#acd898d08216428963563e20f033423b3" title="This mask should be used before sending the register byte when reading or writing. ">REGISTER_MASK</a> before sending the register byte(first byte). </dd></dl>

</div>
</div>
<a id="acd898d08216428963563e20f033423b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd898d08216428963563e20f033423b3">&#9670;&nbsp;</a></span>REGISTER_MASK</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t spiBus::REGISTER_MASK = 0x7E</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This mask should be used before sending the register byte when reading or writing. </p>
<p>This mask will always set the MSB to LOW/0 and will always set the LSB to LOW/0. The MSB has to be LOW to read from a SPI chip and the LSB must always be low because it's not used by the chip All the other bits represent the register address you want to communicate with. You must always use this mask before sending the register byte(first byte). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Demo/<a class="el" href="spi_bus_8hpp_source.html">spiBus.hpp</a></li>
<li>Demo/spiBus.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
